"""
Django settings for bidrl_tools_webapp project.

Generated by 'django-admin startproject' using Django 5.1.3.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path
import sys

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# add parent directory (repository directory) to the path so that config file can be read
sys.path.append(str(BASE_DIR.parent))

from config import DJANGO_SECRET_KEY
import bidrl_functions as bf


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = DJANGO_SECRET_KEY

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['localhost', '127.0.0.1', bf.get_local_ip()]


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'auto_bid',
    'channels',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'bidrl_tools_webapp.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'bidrl_tools_webapp.wsgi.application'
ASGI_APPLICATION = 'bidrl_tools_webapp.asgi.application'

# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': { # use this for all django-interal stuff. will be included in github
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    },
    'bidrl_db': { # use this to store all actual content from the webapp. this will not by included in github for user privacy
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR.parent / 'local_files' / 'auto_bid' / 'auto_bid.db',
    },
}

DATABASE_ROUTERS = ['db_router.AppDBRouter']

# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'




"""
what do we need

- something to monitor a user input zone (whether its a form on webapp or excel sheet) and update the database whenever it updates
    - this way the database will always reflect the user's input and bid desires
    - in the webapp, we can have a submit button that will ultimately write it to the database
    - for the excel option, maybe we have a service running to monitor the excel and update the database when its updated

- a bidrl website -> db updater. this scrapes updated info from bidrl to the database
    - we could have this only run on favorited items for efficiency
    - this runs periodically, maybe every 30 mins, and also when invoked, like by the auto_bid service

- the auto_bid service. this needs to run at all times, reading the database periodically to update from user input,
    and submitting the user's bids
    - this will invoke the bidrl->db updater whenever it needs new / updated data from the website
        - or maybe it'll just pull info directly from bidrl for quick decisions and then invoke the bidrl->db updater after an item ends
            in order to ultimately update the user the result of that item's sale

- the website, which gets all its data from the database, showing the user all their favorited items, their remaining times, etc
    - how will we do remaining times? we can't have the db updater write a new remaining time for every item every second
        - maybe we'll have the end times read from the db and the website use that to show remaining time. then the end times will just update
            if/when they change whenever the bidrl->db updates

"""


"""
narrow down action steps

- user input monitoring - we don't need to do this now. the current version of auto_bid already does this, and when we have user input come
    from the webapp, we'll have the submit button trigger a write to the DB

- bidrl_to_db_updater. we need to write this I think. and have it running as a service. and have it also able to be called, maybe with options

- auto_bid service. I can trim this down to what is needed for phase 2 (just the auto_bid portion)

- presenter. this is currently a print function integrate into auto_bid.py. it will eventually be a website that is fed simply from a django view
    - no development needed at this time in terms of services


"""


"""
plan

- two services needed
    - bidrl_to_db_updater
    - auto_bid
"""



"""
new plan

auto_bid handles most of this stuff anyway. I just need to update it to work more off of the database.

--- make script that simply takes the excel and updates the database
    --- this exclusively brings into the database: item_id, auciton_id, and user input fields like
        max_desired_bid, cost_split, item_bid_group_id, and ibg_items_to_win
        --- we want to update only the values in the database for each item that will not change when the next step updates the rest of the item info

- update auto_bid.py to read only from the database, not from excel
    --- have it update user input info from the database for each item. do this super often
    --- update item info (for just the next upcoming item) multiple times quickly when it's x minutes away
    --- update database every time we update item info
    --- have auto_bid.py run the excel_to_db script at the beginning of its execution

- write the webapp display portion. so that the script can just run all the stuff and the webapp does the displaying

- develop a webform for the user input which writes to the database on submit

- then have auto_bid.py no longer call the excel_to_db script. and it's fully equipped to read user input from the database

"""

"""
I think I can have a script that reads the database for any row where is_bidrl_data_locked_in is false, and then
fast scrapes the auctions those items are included in and updates the database.
this sounds extremely lightweight. like a second of runtime. I feel like I could run this ever 10 seconds or something.

then maybe I could have auto_bid run this every 10 seconds or whatever we want

"""